import re
from abc import ABC, abstractstaticmethod
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Set, Tuple, Type, Union

from graph.blocks import Relations
from graph.neo4j_ import Limit, OrderBy, OrderDirection
from mystery.context_basket.model import Request

from .util import (date_day_to_timestamp, date_string_to_date_day,
                   get_today_date_day, get_today_date_string,
                   get_today_timestamp)


class QueryComponent(ABC):
    '''An abstract class for a component of a Query.'''
    @ abstractstaticmethod
    def from_llm_response(s: str) -> 'QueryComponent':
        '''Converts a string generated by an LLM to a QueryComponent.'''
        raise NotImplementedError

    @ abstractstaticmethod
    def description_for_prompt() -> str:
        '''Returns a description of the component for use in a prompt.'''
        raise NotImplementedError

    @ abstractstaticmethod
    def json_for_prompt() -> str:
        '''Returns how the component should be represented in the prompt's
        sample JSON.'''
        raise NotImplementedError

    @ staticmethod
    def get_component_descriptions() -> str:
        '''Returns a description of all components for use in a prompt.'''
        component_descriptions = [c.description_for_prompt() for c in
                                  QueryComponent.get_components_list()]
        return '\n'.join(component_descriptions)

    @ staticmethod
    def get_json_schema() -> str:
        '''Returns a JSON schema for all components for use in a prompt.'''
        json_parts = [c.json_for_prompt()
                      for c in QueryComponent.get_components_list()]
        return '{\n' + ',\n'.join(json_parts) + '\n}'

    @ staticmethod
    def get_component_from_json_key(key: str) -> 'QueryComponent':
        lookup = {
            'concepts': Concepts,
            'page_participants': PageParticipants,
            'time_frame': AbsoluteTimeFilter,
            'time_sort': RelativeTimeFilter,
            'count': Count,
            'sources': IntegrationsFilter,
            'blocks': BlocksFilter,
            'search_method': SearchMethod,
            'return_type': ReturnType,
        }
        if key not in lookup:
            raise ValueError(f'Invalid key: {key}')
        return lookup[key]

    @ staticmethod
    def get_components_list() -> List['QueryComponent']:
        '''Returns a list of all components as QueryComponent objects.'''
        return [
            Concepts,
            PageParticipants,
            AbsoluteTimeFilter,
            RelativeTimeFilter,
            Count,
            IntegrationsFilter,
            BlocksFilter,
            SearchMethod,
            ReturnType,
        ]


@ dataclass
class Concepts(QueryComponent):
    '''Suggests semantically important concepts from the request.'''
    values: List[str]

    @ staticmethod
    def from_llm_response(llm_response: List[str]) -> 'Concepts':
        if not Concepts._validate_llm_response(llm_response):
            print('Failed to create Concepts from LLM response:',
                  llm_response)
            return None
        return Concepts(llm_response)

    @ staticmethod
    def description_for_prompt() -> str:
        return ('concepts: A list of independent concepts that are '
                'semantically important. These concepts are extracted from '
                'the Request. They should capture whole ideas, not just '
                'individual words. For example, if the request is "Documents '
                'about the role of tech in the office", the concepts should '
                'be ["role of tech in the office"], not ["role", "tech", '
                '"office"].')

    @ staticmethod
    def json_for_prompt() -> str:
        return ' "concepts": string[]'

    @ staticmethod
    def _validate_llm_response(llm_response: List[str]) -> bool:
        return bool(llm_response)


class PageParticipantRole(Enum):
    AUTHOR = 'author'
    RECIPIENT = 'recipient'
    UNKNOWN = 'unknown'


@ dataclass
class PageParticipant:
    name: str
    role: PageParticipantRole

    @property
    def neo4j_relation(self) -> Relations:
        if self.role == PageParticipantRole.AUTHOR:
            return Relations.AUTHOR
        elif self.role == PageParticipantRole.RECIPIENT:
            return Relations.RECIPIENT
        elif self.role == PageParticipantRole.UNKNOWN:
            raise NotImplementedError


@ dataclass
class PageParticipants(QueryComponent):
    '''Enforces that only results linked to these names are considered.'''
    values: List[PageParticipant]

    @ staticmethod
    def from_llm_response(
        llm_response: List[Dict[str, str]]
    ) -> 'PageParticipants':
        # llm_response should be a list of dictionaries with each entry
        # containing keys "name" and "role" that map to strings
        if not PageParticipants._validate_llm_response(llm_response):
            print('Failed to create PageParticipants from LLM response:',
                  llm_response)
            return None
        values = []
        for item in llm_response:
            name = item['name']
            role = item['role']
            if name and role:
                values.append(PageParticipant(
                    name=name,
                    role=PageParticipantRole(role)
                ))
        return PageParticipants(values=values) if values else None

    @ staticmethod
    def description_for_prompt() -> str:
        return ('page_participants: A list of entities , e.g. people or '
                'organizations, that are linked to the creation of the '
                'information you are searching for. They should be paired '
                'with their role in the creation of the information. This '
                'can either be "author" or "recipient". If you know someone '
                'is a page_participant, but don\'t know their role, put '
                '"unknown".')

    @ staticmethod
    def json_for_prompt() -> str:
        return (' "page_participants": {'
                '  "name": string,'
                '  "role": "author" OR "recipient" OR "unknown"'
                ' }')

    @ property
    def neo4j_names(self) -> Set[str]:
        '''Returns a set of names for use in Neo4j.'''
        return set([participant.name for participant in self.values])

    @ staticmethod
    def _validate_llm_response(
        llm_response: List[Dict[str, str]]
    ) -> bool:
        if not llm_response:
            return None
        for item in llm_response:
            if not (item and 'name' in item):
                return False

            if ('role' not in item or not
                (item['role'] == PageParticipantRole.AUTHOR.value or
                    item['role'] == PageParticipantRole.RECIPIENT.value)):
                item['role'] = PageParticipantRole.UNKNOWN.value

        return True


@ dataclass
class AbsoluteTimeFilter(QueryComponent):
    '''Enforces that only results within this time frame are considered. e.g.
    "between 2020 and 2022", "in the last 5 days"'''
    start: int = None
    end: int = None

    @ staticmethod
    def from_llm_response(
        llm_response: Dict[str, str]
    ) -> 'AbsoluteTimeFilter':
        # llm_response should be a dictionary with two keys: 'start' and
        # 'end'. Each value should be a string in the format 'YYYY-MM-DD'.
        start = llm_response.get('start', None)
        end = llm_response.get('end', None)
        start_valid = AbsoluteTimeFilter._validate_date(start)
        end_valid = AbsoluteTimeFilter._validate_date(end)
        if not (start_valid or end_valid):
            print('Failed to create AbsoluteTimeFilter from LLM response:',
                  llm_response)
            return None
        start = date_string_to_date_day(
            llm_response['start']
        ) if start_valid else None
        end = date_string_to_date_day(
            llm_response['end']
        ) if end_valid else None
        return AbsoluteTimeFilter(start=start, end=end)

    @ staticmethod
    def description_for_prompt() -> str:
        current_date = get_today_date_string()
        return ('time_frame: Include time_frame if the Request implies that '
                'the requested information was created within a specific '
                f'time frame. It is currently {current_date}.')

    @ staticmethod
    def json_for_prompt() -> str:
        return (' "time_frame": {\n'
                '  "start": string,\n'
                '  "end": string\n'
                ' }')

    @ property
    def neo4j_time_range(self) -> Tuple[int, int]:
        '''Returns a range of timestamps for use in Neo4j.'''
        start_timestamp = (date_day_to_timestamp(self.start)
                           if self.start else 0)
        end_timestamp = (date_day_to_timestamp(self.end)
                         if self.end else get_today_timestamp())
        return (start_timestamp, end_timestamp)

    @ property
    def pinecone_min_date_day(self) -> int:
        '''Returns the minimum date day for use in Pinecone.'''
        return self.start if self.start else 0

    @ property
    def pinecone_max_date_day(self) -> int:
        '''Returns the maximum date day for use in Pinecone.'''
        return self.end if self.end else get_today_date_day()

    @ staticmethod
    def _validate_date(maybe_date: str) -> bool:
        try:
            return re.match(r'\d{4}-\d{2}-\d{2}', str(maybe_date))
        except:
            return False


@ dataclass
class RelativeTimeFilter(QueryComponent):
    '''Enforces relative ordering of results based on time. e.g.
    "most recent", "oldest"'''
    ascending: bool

    @ staticmethod
    def from_llm_response(
        llm_response: Dict[str, bool]
    ) -> 'RelativeTimeFilter':
        # llm_response should be a dictionary with two keys: 'ascending' and
        # 'count'. The value of 'ascending' should be a boolean and the value
        # of 'count' should be an integer.
        if not RelativeTimeFilter._validate_llm_response(llm_response):
            print('Failed to create RelativeTimeFilter from LLM response:',
                  llm_response)
            return None
        ascending = llm_response['ascending']
        return RelativeTimeFilter(ascending)

    @ staticmethod
    def description_for_prompt() -> str:
        return ('time_sort: Inlude a time_sort if the Request is requesting '
                'information based on a relative ordering of time.')

    @ staticmethod
    def json_for_prompt() -> str:
        return (' "time_sort": {\n'
                '  "ascending": boolean\n'
                ' }')

    @ property
    def neo4j_order_by(self) -> OrderBy:
        '''Returns an OrderBy object for use in Neo4j.'''
        direction = (OrderDirection.ASC
                     if self.ascending else OrderDirection.DESC)
        return OrderBy(direction, 'block', 'last_updated_timestamp')

    @ staticmethod
    def _validate_llm_response(
        llm_response: Dict[str, Union[bool, int]]
    ) -> bool:
        return (llm_response and 'ascending' in llm_response
                and isinstance(llm_response['ascending'], bool))


@dataclass
class Count(QueryComponent):
    '''Enforces a limit on the number of results that are returned.'''
    value: int

    @ staticmethod
    def from_llm_response(llm_response: int) -> 'Count':
        if not isinstance(llm_response, int) or llm_response < 1:
            print('Failed to create Count from LLM response:', llm_response)
            return None
        return Count(llm_response)

    @ staticmethod
    def description_for_prompt() -> str:
        return ('count: Include count if the Request is requesting a '
                'specific number of results.')

    @ staticmethod
    def json_for_prompt() -> str:
        return ' "count": integer'

    @ property
    def neo4j_limit(self) -> Limit:
        '''Returns a Limit object for use in Neo4j.'''
        return Limit(0, self.value)


class Integration(Enum):
    CRM = 'crm'
    CUSTOMER_SUPPORT = 'customer_support'
    DOCUMENTS = 'documents'
    EMAIL = 'email'


@ dataclass
class IntegrationsFilter(QueryComponent):
    '''Enforces that only results from these integrations are considered. e.g.
    'gmail', 'zendesk' '''
    integrations: List[Integration]
    page_ids: List[str] = None

    @ staticmethod
    def from_llm_response(llm_response: List[str]) -> 'IntegrationsFilter':
        if not llm_response:
            return None
        try:
            integrations = [Integration(integration) for integration in
                            llm_response]
        except ValueError:
            print('Failed to create IntegrationsFilter from LLM response:',
                  llm_response)
            return None
        return IntegrationsFilter(integrations)

    @ staticmethod
    def description_for_prompt() -> str:
        data_sources = ', '.join([f'"{integration.value}"' for integration in
                                  Integration])
        data_sources = f'[{data_sources}]'
        return ('sources: Identify any data sources that are referenced in '
                'the Request. The possible data sources are: '
                f'{data_sources}.')

    @ staticmethod
    def json_for_prompt() -> str:
        return ' "sources": string[]'

    @ property
    def neo4j_integrations(self) -> Set[str]:
        '''Returns a list of integration names for use in Neo4j.'''
        return set([self._get_integration_name_from_category(integration)
                    for integration in self.integrations])

    @ property
    def pinecone_integrations(self) -> Set[str]:
        '''Returns a list of integration names for use in Pinecone.'''
        return set([self._get_integration_name_from_category(integration)
                    for integration in self.integrations])

    def _get_integration_name_from_category(self, category: str) -> str:
        if category == Integration.CRM:
            return 'zoho'
        elif category == Integration.CUSTOMER_SUPPORT:
            return 'zendesk'
        elif category == Integration.DOCUMENTS:
            return 'google_docs'
        elif category == Integration.EMAIL:
            return 'google_mail'


class Block(Enum):
    BODY = 'body'
    COMMENT = 'comment'
    CONTACT = 'contact'
    DEAL = 'deal'
    MEMBER = 'member'
    SUMMARY = 'summary'
    TITLE = 'title'


@ dataclass
class BlocksFilter(QueryComponent):
    '''Enforces that only results from these blocks are considered. e.g.
    "title contains", "summarize"'''
    blocks: List[Block]
    block_ids: List[str] = None

    @ staticmethod
    def from_llm_response(llm_response: List[str]) -> 'BlocksFilter':
        if not llm_response:
            return None
        try:
            blocks = [Block(block) for block in llm_response]
        except ValueError:
            print('Failed to create BlocksFilter from LLM response:',
                  llm_response)
            return None
        return BlocksFilter(blocks)

    @ staticmethod
    def description_for_prompt() -> str:
        blocks = ', '.join([f'"{block.value}"' for block in Block])
        blocks = f'[{blocks}]'
        return ('blocks: Include this field only if the information relevant '
                'to the Request is guaranteed to be contained within a '
                'specific block or set of blocks. '
                f'The possible blocks are: {blocks}.')

    @ staticmethod
    def json_for_prompt() -> str:
        return ' "blocks": string[]'

    @ staticmethod
    def get_block_descriptions() -> str:
        return ('"body": The body of the page, e.g. the text in a '
                'Microsoft Word document.\n'
                '"comment": A comment on the page, e.g. a comment on a Jira '
                'ticket.\n'
                '"contact": A contact associated with an account in a CRM.\n'
                '"deal": A deal associated with an account in a CRM.\n'
                '"member": A list of members associated with the page, e.g. '
                'the author, recipients, etc.\n'
                '"summary": A summary of the page.\n'
                '"title": The title of the page.')

    @ property
    def neo4j_labels(self) -> Set[str]:
        '''Returns a list of block labels for use in Neo4j.'''
        return set([block.value for block in self.blocks])

    @ property
    def pinecone_labels(self) -> Set[str]:
        '''Returns a list of block labels for use in Pinecone.'''
        return set([block.value for block in self.blocks])


class SearchMethodValue(Enum):
    RELEVANT = 'relevant'
    EXACT = 'exact'


@ dataclass
class SearchMethod(QueryComponent):
    '''Enforces the method by which results are returned.\n
    Examples:\n
    "all emails from Troy" => "exact"\n
    "emails from Troy related to the budget" => "relevant"'''
    value: SearchMethodValue

    @ staticmethod
    def from_llm_response(llm_response: str) -> 'SearchMethod':
        try:
            value = SearchMethodValue(llm_response)
        except ValueError:
            print('Failed to create SearchMethod from LLM response:',
                  llm_response)
            return None
        return SearchMethod(value)

    @ staticmethod
    def description_for_prompt() -> str:
        return ('search_method: Determine whether the Request is looking '
                'for exact information or the most relevant information.')

    @ staticmethod
    def json_for_prompt() -> str:
        return ' "search_method": "exact" OR "relevant"'


class ReturnTypeValue(Enum):
    PAGES = 'pages'
    BLOCKS = 'blocks'


@ dataclass
class ReturnType(QueryComponent):
    value: str

    @ staticmethod
    def from_llm_response(llm_response: str) -> 'ReturnType':
        try:
            value = ReturnTypeValue(llm_response)
        except ValueError:
            print(
                'Failed to create ReturnType from LLM response:',
                llm_response
            )
            return None
        return ReturnType(value)

    @ staticmethod
    def description_for_prompt() -> str:
        return ('return_type: If the Request is explicitly seeking an '
                'entire page, select "pages". Otherwise, select "blocks". '
                'The pages associated with each data source are: (crm: '
                'Account) (customer_support: Ticket) (documents: Document) '
                '(email: Email Thread)')

    @ staticmethod
    def json_for_prompt() -> str:
        return ' "return_type": "pages" OR "blocks"'


@ dataclass
class Query:
    components: Dict[Type[QueryComponent], QueryComponent]
    request: Request = None

    @ staticmethod
    def from_llm_response(llm_response: Dict[str, Any]) -> 'Query':
        components = {}
        for key, value in llm_response.items():
            try:
                component_class = QueryComponent.get_component_from_json_key(
                    key
                )
            except ValueError:
                print(f'LLM produced invalid query component: {key}')
                continue
            component = component_class.from_llm_response(value)
            if component:
                components[component_class] = component
        return Query(components=components)
